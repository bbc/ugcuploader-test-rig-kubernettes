<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.1.1 r1855137">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Upload" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="campaignId" elementType="Argument">
            <stringProp name="Argument.name">campaignId</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="campaignId1" elementType="Argument">
            <stringProp name="Argument.name">campaignId1</stringProp>
            <stringProp name="Argument.value">u22249586</stringProp>
            <stringProp name="Argument.desc">The id of the campaign</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="campaignId" elementType="Argument">
            <stringProp name="Argument.name">campaignId</stringProp>
            <stringProp name="Argument.value">u22417071</stringProp>
            <stringProp name="Argument.desc">anonymous</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="campaignId3" elementType="Argument">
            <stringProp name="Argument.name">campaignId3</stringProp>
            <stringProp name="Argument.value">u16720794</stringProp>
            <stringProp name="Argument.desc">not working</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="campaignId4" elementType="Argument">
            <stringProp name="Argument.name">campaignId4</stringProp>
            <stringProp name="Argument.value">u34876134</stringProp>
            <stringProp name="Argument.desc">national moments on test</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <kg.apc.jmeter.config.VariablesFromCSV guiclass="kg.apc.jmeter.config.VariablesFromCSVGui" testclass="kg.apc.jmeter.config.VariablesFromCSV" testname="set bandwidth" enabled="true">
        <collectionProp name="Arguments.arguments"/>
        <stringProp name="filename">/config/bandwidth.csv</stringProp>
        <stringProp name="variablesPrefix"></stringProp>
        <stringProp name="delimiter">,</stringProp>
        <intProp name="skipLines">0</intProp>
        <boolProp name="storeSysProp">false</boolProp>
      </kg.apc.jmeter.config.VariablesFromCSV>
      <hashTree/>
      <ConfigTestElement guiclass="PropertyControlGui" testclass="ConfigTestElement" testname="Property Display" enabled="true"/>
      <hashTree/>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Upload File -TestTenant" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.duration">86400</stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Upload-${__property(TENNANT,&quot;Not Found&quot;)}" enabled="true">
          <elementProp name="HTTPsampler.Files" elementType="HTTPFileArgs">
            <collectionProp name="HTTPFileArgs.files">
              <elementProp name="${__P(test.data,&quot;hmm&quot;)}/1600px-Snake_River_5MB.jpg" elementType="HTTPFileArg">
                <stringProp name="File.path">${__P(test.data,&quot;hmm&quot;)}/1600px-Snake_River_5MB.jpg</stringProp>
                <stringProp name="File.paramname">data</stringProp>
                <stringProp name="File.mimetype">image/jpeg</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
    &quot;txt10930738&quot;: &quot;me@national-moements.com&quot;,&#xd;
    &quot;txt17075857&quot;: &quot;All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. However, they cannothave IP connectivity to any host outside of the enterprise. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. However, they cannothave IP connectivity to any host outside of the enterprise. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Such hosts will use the private address spacedefined above. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Indirect references to such addresses should be contained within theenterprise. However, they cannothave IP connectivity to any host outside of the enterprise. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. . Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. . In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. However, they cannothave IP connectivity to any host outside of the enterprise. Such hosts will use the private address spacedefined above. In particular, Internet service providers should takemeasures to prevent such leakage. Private hosts can communicate with all other hostsinside the enterprise, both public and private. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. However, they cannothave IP connectivity to any host outside of the enterprise. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. However, they cannothave IP connectivity to any host outside of the enterprise. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Private hosts can communicate with all other hostsinside the enterprise, both public and private. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Such hosts will use the private address spacedefined above. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. However, they cannothave IP connectivity to any host outside of the enterprise. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. In particular, Internet service providers should takemeasures to prevent such leakage. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Such hosts will use the private address spacedefined above. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. In particular, Internet service providers should takemeasures to prevent such leakage. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Such hosts will use the private address spacedefined above. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Public hosts do not have connectivity to private hosts of otherenterprises. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. In particular, Internet service providers should takemeasures to prevent such leakage. Indirect references to such addresses should be contained within theenterprise. In particular, Internet service providers should takemeasures to prevent such leakage. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. . Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. However, they cannothave IP connectivity to any host outside of the enterprise. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Indirect references to such addresses should be contained within theenterprise. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. However, they cannothave IP connectivity to any host outside of the enterprise. Indirect references to such addresses should be contained within theenterprise. The address space can thus be usedby many enterprises. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. . An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. Such hosts will use the private address spacedefined above. . Public hosts do not have connectivity to private hosts of otherenterprises. Private hosts can communicate with all other hostsinside the enterprise, both public and private. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. Public hosts do not have connectivity to private hosts of otherenterprises. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. The address space can thus be usedby many enterprises. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Private hosts can communicate with all other hostsinside the enterprise, both public and private. Public hosts do not have connectivity to private hosts of otherenterprises. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. In particular, Internet service providers should takemeasures to prevent such leakage. However, they cannothave IP connectivity to any host outside of the enterprise. Indirect references to such addresses should be contained within theenterprise. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. In particular, Internet service providers should takemeasures to prevent such leakage. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. . Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. . Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Indirect references to such addresses should be contained within theenterprise. Indirect references to such addresses should be contained within theenterprise. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Indirect references to such addresses should be contained within theenterprise. However, they cannothave IP connectivity to any host outside of the enterprise. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. In particular, Internet service providers should takemeasures to prevent such leakage. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. In particular, Internet service providers should takemeasures to prevent such leakage. Such hosts will use the private address spacedefined above. The address space can thus be usedby many enterprises. Private hosts can communicate with all other hostsinside the enterprise, both public and private. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Such hosts will use the private address spacedefined above. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. . . Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. However, they cannothave IP connectivity to any host outside of the enterprise. Private hosts can communicate with all other hostsinside the enterprise, both public and private. . Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Public hosts do not have connectivity to private hosts of otherenterprises. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. However, they cannothave IP connectivity to any host outside of the enterprise. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. . All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. However, they cannothave IP connectivity to any host outside of the enterprise. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. The address space can thus be usedby many enterprises. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Indirect references to such addresses should be contained within theenterprise. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Indirect references to such addresses should be contained within theenterprise. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Indirect references to such addresses should be contained within theenterprise. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. The address space can thus be usedby many enterprises. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. In particular, Internet service providers should takemeasures to prevent such leakage. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. In particular, Internet service providers should takemeasures to prevent such leakage. Private hosts can communicate with all other hostsinside the enterprise, both public and private. However, they cannothave IP connectivity to any host outside of the enterprise. However, they cannothave IP connectivity to any host outside of the enterprise. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. In particular, Internet service providers should takemeasures to prevent such leakage. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. However, they cannothave IP connectivity to any host outside of the enterprise. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. In particular, Internet service providers should takemeasures to prevent such leakage. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Private hosts can communicate with all other hostsinside the enterprise, both public and private. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. The address space can thus be usedby many enterprises. . Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. . We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Private hosts can communicate with all other hostsinside the enterprise, both public and private. However, they cannothave IP connectivity to any host outside of the enterprise. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Private hosts can communicate with all other hostsinside the enterprise, both public and private. Such hosts will use the private address spacedefined above. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. The address space can thus be usedby many enterprises. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Private hosts can communicate with all other hostsinside the enterprise, both public and private. Private hosts can communicate with all other hostsinside the enterprise, both public and private. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. Indirect references to such addresses should be contained within theenterprise. Public hosts do not have connectivity to private hosts of otherenterprises. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. However, they cannothave IP connectivity to any host outside of the enterprise. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Public hosts do not have connectivity to private hosts of otherenterprises. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. However, they cannothave IP connectivity to any host outside of the enterprise. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Such hosts will use the private address spacedefined above. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. However, they cannothave IP connectivity to any host outside of the enterprise. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Indirect references to such addresses should be contained within theenterprise. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. The address space can thus be usedby many enterprises. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Indirect references to such addresses should be contained within theenterprise. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Private hosts can communicate with all other hostsinside the enterprise, both public and private. In particular, Internet service providers should takemeasures to prevent such leakage. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. . Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. . . Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. Such hosts will use the private address spacedefined above. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. The address space can thus be usedby many enterprises. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Indirect references to such addresses should be contained within theenterprise. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. . Public hosts do not have connectivity to private hosts of otherenterprises. Public hosts do not have connectivity to private hosts of otherenterprises. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Private hosts can communicate with all other hostsinside the enterprise, both public and private. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Indirect references to such addresses should be contained within theenterprise. Private hosts can communicate with all other hostsinside the enterprise, both public and private. Such hosts will use the private address spacedefined above. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Such hosts will use the private address spacedefined above. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. The address space can thus be usedby many enterprises. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. The address space can thus be usedby many enterprises. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. In particular, Internet service providers should takemeasures to prevent such leakage. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. However, they cannothave IP connectivity to any host outside of the enterprise. However, they cannothave IP connectivity to any host outside of the enterprise. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. Such hosts will use the private address spacedefined above. The address space can thus be usedby many enterprises. The address space can thus be usedby many enterprises. However, they cannothave IP connectivity to any host outside of the enterprise. The address space can thus be usedby many enterprises. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. . All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. The address space can thus be usedby many enterprises. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Indirect references to such addresses should be contained within theenterprise. However, they cannothave IP connectivity to any host outside of the enterprise. The address space can thus be usedby many enterprises. Private hosts can communicate with all other hostsinside the enterprise, both public and private. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. The address space can thus be usedby many enterprises. Private hosts can communicate with all other hostsinside the enterprise, both public and private. . Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. Private hosts can communicate with all other hostsinside the enterprise, both public and private. . As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Public hosts do not have connectivity to private hosts of otherenterprises. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. In particular, Internet service providers should takemeasures to prevent such leakage. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. . In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. In particular, Internet service providers should takemeasures to prevent such leakage. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. Indirect references to such addresses should be contained within theenterprise. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. In particular, Internet service providers should takemeasures to prevent such leakage. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. In particular, Internet service providers should takemeasures to prevent such leakage. The address space can thus be usedby many enterprises. In order to use private address space, an enterprise needs todetermine which hosts do not need to have network layer connectivityoutside the enterprise in the foreseeable future and thus could beclassified as private. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Public hosts do not have connectivity to private hosts of otherenterprises. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. In particular, Internet service providers should takemeasures to prevent such leakage. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Such hosts will use the private address spacedefined above. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. However, they cannothave IP connectivity to any host outside of the enterprise. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Public hosts do not have connectivity to private hosts of otherenterprises. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. . Routers in networks notusing private address space, especially those of Internet serviceproviders, are expected to be configured to reject (filter out)routing information about private networks. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. Indirect references to such addresses should be contained within theenterprise. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Public hosts can communicatewith other hosts inside the enterprise both public and private andcan have IP connectivity to public hosts outside the enterprise. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. Note that (inpre-CIDR notation) the first block is nothing but a single class Anetwork number, while the second block is a set of 16 contiguousclass B network numbers, and third block is a set of 256 contiguousclass C network numbers. Public hosts do not have connectivity to private hosts of otherenterprises. While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. If such a router receivessuch information the rejection shall not be treated as a routingprotocol error. Anenterprise that requests IP addresses for its external connectivitywill never be assigned addresses from the blocks defined above. . Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. Moving a host from private to public or vice versa involves a changeof IP address, changes to the appropriate DNS entries, and changes toconfiguration files on other hosts that reference the host by IPaddress. . While nothaving external (outside of the enterprise) IP connectivity privatehosts can still have access to external services via mediatinggateways. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. All other hosts will be public and will use globally unique addressspace assigned by an Internet Registry. Public hosts do not have connectivity to private hosts of otherenterprises. Public hosts do not have connectivity to private hosts of otherenterprises. Indirect references to such addresses should be contained within theenterprise. Because private addresses have no global meaning, routing informationabout private networks shall not be propagated on inter-enterpriselinks, and packets with private source or destination addressesshould not be forwarded across such links. As before, any enterprise that needs globally unique address space isrequired to obtain such addresses from an Internet registry. An enterprise that decides to use IP addresses out of the addressspace defined in this document can do so without any coordinationwith IANA or an Internet registry. Prominent examples of such references are DNS ResourceRecords and other information referring to internal privateaddresses. Addresses within this private address space willonly be unique within the enterprise, or the set of enterprises whichchoose to cooperate over this space so they may communicate with eachother in their own private internet. Indirect references to such addresses should be contained within theenterprise. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block. We will refer to the first block as &quot;24-bit block&quot;, the second as&quot;20-bit block&quot;, and to the third as &quot;16-bit&quot; block.&quot;,&#xd;
    &quot;txt34848860&quot;: &quot;supplied&quot;,&#xd;
    &quot;txt34848951&quot;: &quot;supplied&quot;&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">www.int.bbc.co.uk</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">ugc/send/${campaignId}?txt10930738=email</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">true</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="Extract SubmissionId" enabled="true">
            <stringProp name="JSONPostProcessor.referenceNames">subId</stringProp>
            <stringProp name="JSONPostProcessor.jsonPathExprs">$.submissionId</stringProp>
            <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
            <stringProp name="Sample.scope">variable</stringProp>
            <stringProp name="Scope.variable"></stringProp>
            <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
          </JSONPostProcessor>
          <hashTree/>
          <ResultSaver guiclass="ResultSaverGui" testclass="ResultSaver" testname="Save Responses to a file" enabled="true">
            <stringProp name="FileSaver.filename">${__P(test.results,&quot;hmm&quot;)}/upload.json</stringProp>
            <boolProp name="FileSaver.errorsonly">false</boolProp>
            <boolProp name="FileSaver.successonly">false</boolProp>
            <boolProp name="FileSaver.skipsuffix">false</boolProp>
            <boolProp name="FileSaver.skipautonumber">false</boolProp>
          </ResultSaver>
          <hashTree/>
          <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname=" PreProcessor-AddAuthenticationCookies" enabled="false">
            <stringProp name="scriptLanguage">groovy</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">//sampler.setProtocol(vars.get(&quot;LOGION_PROTOCOL&quot;))
//sampler.setDomain(vars.get(&quot;LOGIN_DOMAIN&quot;))
//sampler.setPath(vars.get(&quot;LOGIN_PATH&quot;))
//log.info(&quot;----- BEFORE LOGIN ${__property(UGC_CKNS_MVT)}&quot;)
import org.apache.jmeter.protocol.http.control.CookieManager;

import org.apache.jmeter.protocol.http.control.Cookie;
import org.apache.jmeter.testelement.property.JMeterProperty;
CookieManager manager = ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;).getObjectValue();
count = Integer.parseInt(props.getProperty(&quot;cookiecount&quot;));

       Cookie cknsIdtkCookie = new
		Cookie(
			props.getProperty(&quot;cookie_name_ckns_idtkn&quot;),
			props.getProperty(&quot;cookie_value_ckns_idtkn&quot;), 
			props.getProperty(&quot;cookie_domain_ckns_idtkn&quot;),
			props.getProperty(&quot;cookie_path_ckns_idtkn&quot;), 
			Boolean.parseBoolean(props.getProperty(&quot;cookie_secure_ckns_idtkn&quot;)), 
			Long.parseLong(props.getProperty(&quot;cookie_expires_ckns_idtkn&quot;))
			);

	
	manager.add(cknsIdtkCookie);

	      Cookie cknsAtknCookie = new
		Cookie(
			props.getProperty(&quot;cookie_name_ckns_atkn&quot;),
			props.getProperty(&quot;cookie_value_ckns_atkn&quot;), 
			props.getProperty(&quot;cookie_domain_ckns_atkn&quot;),
			props.getProperty(&quot;cookie_path_ckns_atkn&quot;), 
			Boolean.parseBoolean(props.getProperty(&quot;cookie_secure_ckns_atkn&quot;)), 
			Long.parseLong(props.getProperty(&quot;cookie_expires_ckns_atkn&quot;))
			);

	
	manager.add(cknsAtknCookie);
	
JMeterProperty cookieprop = 
ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;);
cookieprop.setObjectValue(manager);

//ctx.getCurrentSampler().setProperty(myprop);</stringProp>
          </JSR223PreProcessor>
          <hashTree/>
        </hashTree>
        <ConstantThroughputTimer guiclass="TestBeanGUI" testclass="ConstantThroughputTimer" testname="Constant Throughput Timer" enabled="true">
          <intProp name="calcMode">0</intProp>
          <doubleProp>
            <name>throughput</name>
            <value>60.0</value>
            <savedValue>0.0</savedValue>
          </doubleProp>
        </ConstantThroughputTimer>
        <hashTree/>
        <CookieManager guiclass="CookiePanel" testclass="CookieManager" testname="HTTP Cookie Manager" enabled="true">
          <collectionProp name="CookieManager.cookies"/>
          <boolProp name="CookieManager.clearEachIteration">true</boolProp>
        </CookieManager>
        <hashTree/>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="false">
          <boolProp name="LoopController.continue_forever">true</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </LoopController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Session" enabled="false">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="Variables pr-dfinies" enabled="true">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
            <stringProp name="HTTPSampler.domain">session.test.bbc.co.uk</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/session</stringProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.implementation">Java</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="ExtractLoginLocation" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">true</stringProp>
              <stringProp name="RegexExtractor.refname">LOCATION</stringProp>
              <stringProp name="RegexExtractor.regex">Location:\s+(.+)</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default"></stringProp>
              <stringProp name="RegexExtractor.match_number">0</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
            </RegexExtractor>
            <hashTree/>
            <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="PostProcessor-SetLoginLocation" enabled="true">
              <stringProp name="scriptLanguage">groovy</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">import org.apache.jmeter.protocol.http.control.CookieManager
loc = vars.get(&quot;LOCATION&quot;)
log.debug(&quot;LOCATION=&quot;+loc)
if (loc) {
	loc = new URL(loc)
	h = loc.getPath()+&quot;?&quot;+loc.query;
	props.put(&quot;LOGIN_PATH&quot;, h)
	props.put(&quot;LOGIN_HOST&quot;, loc.getHost())
	props.put(&quot;LOGIN_PROTOCOL&quot;, String.valueOf(loc.getProtocol()))

}

 
 

CookieManager manager = 
ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;).getObjectValue();
props.put(&quot;cookiecount&quot;,String.valueOf(manager.getCookieCount()));
for (int i=0;i&lt;manager.getCookieCount();i++){
                 // code to convert Cookie information to JMeter Properties
    props.put(&quot;cookie_name_&quot; + i, manager.get(i).getName());
    props.put(&quot;cookie_value_&quot;+i, manager.get(i).getValue());
    props.put(&quot;cookie_domain_&quot;+i, manager.get(i).getDomain());
    props.put(&quot;cookie_path_&quot;+i, manager.get(i).getPath());
    props.put(&quot;cookie_expires_&quot;+i, String.valueOf(manager.get(i).getExpires())); 
    props.put(&quot;cookie_secure_&quot;+i, String.valueOf(manager.get(i).getSecure()));

}
 </stringProp>
            </JSR223PostProcessor>
            <hashTree/>
            <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="PreProcessor-ClearCookies" enabled="true">
              <stringProp name="scriptLanguage">groovy</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">import org.apache.jmeter.protocol.http.sampler.HTTPSamplerProxy;
import org.apache.jmeter.protocol.http.control.CookieManager;

log.debug(&quot;------------------- DING&quot;);
HTTPSamplerProxy hsp = ctx.getCurrentSampler();

hsp.setDomain(&quot;session.test.bbc.co.uk&quot;);
hsp.setPath(&quot;/session&quot;);
sampler.getCookieManager().getCookies().clear();
</stringProp>
            </JSR223PreProcessor>
            <hashTree/>
            <ConfigTestElement guiclass="TCPConfigGui" testclass="ConfigTestElement" testname="TCP Sampler Config" enabled="true">
              <stringProp name="TCPSampler.server"></stringProp>
              <boolProp name="TCPSampler.reUseConnection">true</boolProp>
              <stringProp name="TCPSampler.port"></stringProp>
              <boolProp name="TCPSampler.nodelay">false</boolProp>
              <stringProp name="TCPSampler.timeout"></stringProp>
              <stringProp name="TCPSampler.request"></stringProp>
              <boolProp name="TCPSampler.closeConnection">false</boolProp>
            </ConfigTestElement>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Login" enabled="false">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="Variables pr-dfinies" enabled="true">
              <collectionProp name="Arguments.arguments">
                <elementProp name="username" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">ugc-under13-testuser1</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">username</stringProp>
                  <stringProp name="HTTPArgument.content_type">application/x-www-form-urlencoded</stringProp>
                </elementProp>
                <elementProp name="password" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">test4656</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="HTTPArgument.content_type">application/x-www-form-urlencoded</stringProp>
                  <stringProp name="Argument.name">password</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${__property(LOGIN_HOST)}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${__property(LOGIN_PROTOCOL)}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">${__property(LOGIN_PATH)}</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <boolProp name="HTTPSampler.BROWSER_COMPATIBLE_MULTIPART">true</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.implementation">Java</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="Fetch CKNS_ATKN and CKNS_IDTKN cookies" enabled="true">
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import org.apache.jmeter.protocol.http.control.*
//Get cookie manager
CookieManager cm = sampler.getCookieManager()


int cc = cm.getCookieCount()
log.debug(&quot;************ NUMBER OF COOKIES&quot;+cc);
for(i =0; i &lt; cc; i++) {

	Cookie c = cm.get(i)
	log.debug(&quot;POSTING:******************** Cookies #&quot;+i+&quot;: &quot; + c.getName() + &quot;   - cookie Value: &quot; + c.getValue())	

	if (c.getName().equalsIgnoreCase(&quot;ckns_atkn&quot;)) {
		props.put(&quot;UGC_CKNSATKN&quot;, c.getValue());
		props.put(&quot;cookie_name_ckns_atkn&quot;, c.getName());
          props.put(&quot;cookie_value_ckns_atkn&quot;, c.getValue());
          props.put(&quot;cookie_domain_ckns_atkn&quot;, c.getDomain());
          props.put(&quot;cookie_path_ckns_atkn&quot;, c.getPath());
          props.put(&quot;cookie_expires_ckns_atkn&quot;, String.valueOf(c.getExpires())); 
          props.put(&quot;cookie_secure_ckns_atkn&quot;, String.valueOf(c.getSecure()));
	}

	if (c.getName().equalsIgnoreCase(&quot;ckns_idtkn&quot;)) {
		props.put(&quot;UGC_CKNSIDTKN&quot;, c.getValue());
		props.put(&quot;cookie_name_ckns_idtkn&quot;, c.getName());
          props.put(&quot;cookie_value_ckns_idtkn&quot;, c.getValue());
          props.put(&quot;cookie_domain_ckns_idtkn&quot;, c.getDomain());
          props.put(&quot;cookie_path_ckns_idtkn&quot;, c.getPath());
          props.put(&quot;cookie_expires_ckns_idtkn&quot;, String.valueOf(c.getExpires())); 
          props.put(&quot;cookie_secure_ckns_idtkn&quot;, String.valueOf(c.getSecure()));
	}
	
	if (c.getName().equalsIgnoreCase(&quot;ckns_id-session-redirect&quot;)){
		props.put(&quot;UGC_ckns_id-session-redirect&quot;, c.getValue());
		props.put(&quot;UGC_ckns_id-session-redirect_DOMAIN&quot;, c.getDomain());
	}

}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223PostProcessor>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="-1648040284">500|302|200</stringProp>
              </collectionProp>
              <stringProp name="Assertion.custom_message"></stringProp>
              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
              <boolProp name="Assertion.assume_success">true</boolProp>
              <intProp name="Assertion.test_type">2</intProp>
            </ResponseAssertion>
            <hashTree/>
          </hashTree>
        </hashTree>
        <BackendListener guiclass="BackendListenerGui" testclass="BackendListener" testname="Backend Listener" enabled="true">
          <elementProp name="arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="testName" elementType="Argument">
                <stringProp name="Argument.name">testName</stringProp>
                <stringProp name="Argument.value">UgcUploadTest</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="nodeName" elementType="Argument">
                <stringProp name="Argument.name">nodeName</stringProp>
                <stringProp name="Argument.value">Test-Node</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBHost" elementType="Argument">
                <stringProp name="Argument.name">influxDBHost</stringProp>
                <stringProp name="Argument.value">influxdb-jmeter.ugcload-reporter.svc.cluster.local</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBPort" elementType="Argument">
                <stringProp name="Argument.name">influxDBPort</stringProp>
                <stringProp name="Argument.value">8086</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBUser" elementType="Argument">
                <stringProp name="Argument.name">influxDBUser</stringProp>
                <stringProp name="Argument.value">jmeter</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBPassword" elementType="Argument">
                <stringProp name="Argument.name">influxDBPassword</stringProp>
                <stringProp name="Argument.value"></stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBDatabase" elementType="Argument">
                <stringProp name="Argument.name">influxDBDatabase</stringProp>
                <stringProp name="Argument.value">ugcloadtest</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="retentionPolicy" elementType="Argument">
                <stringProp name="Argument.name">retentionPolicy</stringProp>
                <stringProp name="Argument.value">autogen</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="samplersList" elementType="Argument">
                <stringProp name="Argument.name">samplersList</stringProp>
                <stringProp name="Argument.value">.*</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="useRegexForSamplerList" elementType="Argument">
                <stringProp name="Argument.name">useRegexForSamplerList</stringProp>
                <stringProp name="Argument.value">true</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="classname">rocks.nt.apm.jmeter.JMeterInfluxDBBackendListenerClient</stringProp>
        </BackendListener>
        <hashTree/>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="Debug Sampler" enabled="true">
          <boolProp name="displayJMeterProperties">false</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
      </hashTree>
      <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Upload File" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">true</boolProp>
          <stringProp name="LoopController.loops">2</stringProp>
        </LoopController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Session" enabled="true">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="Variables pr-dfinies" enabled="true">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
            <stringProp name="HTTPSampler.domain">session.test.bbc.co.uk</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/session</stringProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.implementation">Java</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="ExtractLoginLocation" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">true</stringProp>
              <stringProp name="RegexExtractor.refname">LOCATION</stringProp>
              <stringProp name="RegexExtractor.regex">Location:\s+(.+)</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default"></stringProp>
              <stringProp name="RegexExtractor.match_number">0</stringProp>
              <stringProp name="Sample.scope">all</stringProp>
            </RegexExtractor>
            <hashTree/>
            <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="PostProcessor-SetLoginLocation" enabled="true">
              <stringProp name="scriptLanguage">groovy</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">import org.apache.jmeter.protocol.http.control.CookieManager
loc = vars.get(&quot;LOCATION&quot;)
if (loc) {
	loc = new URL(loc)
	h = loc.getPath()+&quot;?&quot;+loc.query;
	props.put(&quot;LOGIN_PATH&quot;, h)
	props.put(&quot;LOGIN_HOST&quot;, loc.getHost())
	props.put(&quot;LOGIN_PROTOCOL&quot;, String.valueOf(loc.getProtocol()))

}

 
 

CookieManager manager = 
ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;).getObjectValue();
props.put(&quot;cookiecount&quot;,String.valueOf(manager.getCookieCount()));
for (int i=0;i&lt;manager.getCookieCount();i++){
                 // code to convert Cookie information to JMeter Properties
    props.put(&quot;cookie_name_&quot; + i, manager.get(i).getName());
    props.put(&quot;cookie_value_&quot;+i, manager.get(i).getValue());
    props.put(&quot;cookie_domain_&quot;+i, manager.get(i).getDomain());
    props.put(&quot;cookie_path_&quot;+i, manager.get(i).getPath());
    props.put(&quot;cookie_expires_&quot;+i, String.valueOf(manager.get(i).getExpires())); 
    props.put(&quot;cookie_secure_&quot;+i, String.valueOf(manager.get(i).getSecure()));

}
 </stringProp>
            </JSR223PostProcessor>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Login" enabled="true">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="Variables pr-dfinies" enabled="true">
              <collectionProp name="Arguments.arguments">
                <elementProp name="username" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">ugc-under13-testuser1</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">username</stringProp>
                  <stringProp name="HTTPArgument.content_type">application/x-www-form-urlencoded</stringProp>
                </elementProp>
                <elementProp name="password" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">test4656</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="HTTPArgument.content_type">application/x-www-form-urlencoded</stringProp>
                  <stringProp name="Argument.name">password</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${__property(LOGIN_HOST)}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">${__property(LOGIN_PROTOCOL)}</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">${__property(LOGIN_PATH)}</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <boolProp name="HTTPSampler.BROWSER_COMPATIBLE_MULTIPART">true</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.implementation">Java</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="Fetch CKNS_ATKN and CKNS_IDTKN cookies" enabled="true">
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import org.apache.jmeter.protocol.http.control.*
//Get cookie manager
CookieManager cm = sampler.getCookieManager()


int cc = cm.getCookieCount()
log.info(&quot;************ NUMBER OF COOKIES&quot;+cc);
for(i =0; i &lt; cc; i++) {

	Cookie c = cm.get(i)
	log.info(&quot;POSTING:******************** Cookies #&quot;+i+&quot;: &quot; + c.getName() + &quot;   - cookie Value: &quot; + c.getValue())	

	if (c.getName().equalsIgnoreCase(&quot;ckns_atkn&quot;)) {
		props.put(&quot;UGC_CKNSATKN&quot;, c.getValue());
		props.put(&quot;cookie_name_ckns_atkn&quot;, c.getName());
          props.put(&quot;cookie_value_ckns_atkn&quot;, c.getValue());
          props.put(&quot;cookie_domain_ckns_atkn&quot;, c.getDomain());
          props.put(&quot;cookie_path_ckns_atkn&quot;, c.getPath());
          props.put(&quot;cookie_expires_ckns_atkn&quot;, String.valueOf(c.getExpires())); 
          props.put(&quot;cookie_secure_ckns_atkn&quot;, String.valueOf(c.getSecure()));
	}

	if (c.getName().equalsIgnoreCase(&quot;ckns_idtkn&quot;)) {
		props.put(&quot;UGC_CKNSIDTKN&quot;, c.getValue());
		props.put(&quot;cookie_name_ckns_idtkn&quot;, c.getName());
          props.put(&quot;cookie_value_ckns_idtkn&quot;, c.getValue());
          props.put(&quot;cookie_domain_ckns_idtkn&quot;, c.getDomain());
          props.put(&quot;cookie_path_ckns_idtkn&quot;, c.getPath());
          props.put(&quot;cookie_expires_ckns_idtkn&quot;, String.valueOf(c.getExpires())); 
          props.put(&quot;cookie_secure_ckns_idtkn&quot;, String.valueOf(c.getSecure()));

	}

	if (c.getName().equalsIgnoreCase(&quot;ckns_mvt&quot;)){
		log.info(&quot;SETTING&quot;);
		props.put(&quot;UGC_CKNS_MVT&quot;, c.getValue());
		props.put(&quot;UGC_CKNS_MVT_DOMAIN&quot;, c.getDomain());
	}
	
	if (c.getName().equalsIgnoreCase(&quot;ckns_nonce&quot;)){

		props.put(&quot;UGC_CKNS_NONCE&quot;, c.getValue());
		props.put(&quot;UGC_CKNS_NONCE_DOMAIN&quot;, c.getDomain());
	}

	
	if (c.getName().equalsIgnoreCase(&quot;ckns_id-session-redirect&quot;)){

		props.put(&quot;UGC_ckns_id-session-redirect&quot;, c.getValue());
		props.put(&quot;UGC_ckns_id-session-redirect_DOMAIN&quot;, c.getDomain());
	}

	


}
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223PostProcessor>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="-1648040284">500|302|200</stringProp>
              </collectionProp>
              <stringProp name="Assertion.custom_message"></stringProp>
              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
              <boolProp name="Assertion.assume_success">true</boolProp>
              <intProp name="Assertion.test_type">2</intProp>
            </ResponseAssertion>
            <hashTree/>
            <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="Preprocessor-AddSessionCookie" enabled="true">
              <stringProp name="scriptLanguage">groovy</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">//sampler.setProtocol(vars.get(&quot;LOGION_PROTOCOL&quot;))
//sampler.setDomain(vars.get(&quot;LOGIN_DOMAIN&quot;))
//sampler.setPath(vars.get(&quot;LOGIN_PATH&quot;))
//log.info(&quot;----- BEFORE LOGIN ${__property(UGC_CKNS_MVT)}&quot;)
import org.apache.jmeter.protocol.http.control.CookieManager;

import org.apache.jmeter.protocol.http.control.Cookie;
import org.apache.jmeter.testelement.property.JMeterProperty;
CookieManager manager =

ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;).getObjectValue();
count = Integer.parseInt(props.getProperty(&quot;cookiecount&quot;));

for (int i=0; i&lt;count; i++) {
//	  log.info(&quot;----INSIDE &quot;+props.getProperty(&quot;cookie_name_&quot;+i);
 
       Cookie cookie = new
		Cookie(
			props.getProperty(&quot;cookie_name_&quot;+i),
			props.getProperty(&quot;cookie_value_&quot;+i), 
			props.getProperty(&quot;cookie_domain_&quot;+i),
			props.getProperty(&quot;cookie_path_&quot;+i), 
			Boolean.parseBoolean(props.getProperty(&quot;cookie_secure_&quot;+i)), 
			Long.parseLong(props.getProperty(&quot;cookie_expires_&quot;+i))
			);

	
	manager.add(cookie);
}
JMeterProperty cookieprop = 
ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;);
cookieprop.setObjectValue(manager);

//ctx.getCurrentSampler().setProperty(myprop);</stringProp>
            </JSR223PreProcessor>
            <hashTree/>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Upload-Login" enabled="true">
            <elementProp name="HTTPsampler.Files" elementType="HTTPFileArgs">
              <collectionProp name="HTTPFileArgs.files">
                <elementProp name="${__P(test.data,&quot;hmm&quot;)}/1600px-Snake_River_5MB.jpg" elementType="HTTPFileArg">
                  <stringProp name="File.path">${__P(test.data,&quot;hmm&quot;)}/1600px-Snake_River_5MB.jpg</stringProp>
                  <stringProp name="File.paramname">data</stringProp>
                  <stringProp name="File.mimetype">image/jpeg</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="Variables pr-dfinies" enabled="true">
              <collectionProp name="Arguments.arguments">
                <elementProp name="txt10930738" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">email</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">txt10930738</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">www.int.bbc.co.uk</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">ugc/send/${campaignId}</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">true</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.implementation">Java</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="Extract SubmissionId" enabled="true">
              <stringProp name="JSONPostProcessor.referenceNames">subId</stringProp>
              <stringProp name="JSONPostProcessor.jsonPathExprs">$.submissionId</stringProp>
              <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
              <stringProp name="Sample.scope">variable</stringProp>
              <stringProp name="Scope.variable"></stringProp>
              <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
            </JSONPostProcessor>
            <hashTree/>
            <ResultSaver guiclass="ResultSaverGui" testclass="ResultSaver" testname="Save Responses to a file" enabled="true">
              <stringProp name="FileSaver.filename">${__P(test.results,&quot;hmm&quot;)}/upload.json</stringProp>
              <boolProp name="FileSaver.errorsonly">false</boolProp>
              <boolProp name="FileSaver.successonly">false</boolProp>
              <boolProp name="FileSaver.skipsuffix">false</boolProp>
              <boolProp name="FileSaver.skipautonumber">false</boolProp>
            </ResultSaver>
            <hashTree/>
            <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname=" PreProcessor-AddAuthenticationCookies" enabled="true">
              <stringProp name="scriptLanguage">groovy</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">//sampler.setProtocol(vars.get(&quot;LOGION_PROTOCOL&quot;))
//sampler.setDomain(vars.get(&quot;LOGIN_DOMAIN&quot;))
//sampler.setPath(vars.get(&quot;LOGIN_PATH&quot;))
//log.info(&quot;----- BEFORE LOGIN ${__property(UGC_CKNS_MVT)}&quot;)
import org.apache.jmeter.protocol.http.control.CookieManager;

import org.apache.jmeter.protocol.http.control.Cookie;
import org.apache.jmeter.testelement.property.JMeterProperty;
CookieManager manager =

ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;).getObjectValue();
count = Integer.parseInt(props.getProperty(&quot;cookiecount&quot;));

       Cookie cknsIdtkCookie = new
		Cookie(
			props.getProperty(&quot;cookie_name_ckns_idtkn&quot;),
			props.getProperty(&quot;cookie_value_ckns_idtkn&quot;), 
			props.getProperty(&quot;cookie_domain_ckns_idtkn&quot;),
			props.getProperty(&quot;cookie_path_ckns_idtkn&quot;), 
			Boolean.parseBoolean(props.getProperty(&quot;cookie_secure_ckns_idtkn&quot;)), 
			Long.parseLong(props.getProperty(&quot;cookie_expires_ckns_idtkn&quot;))
			);

	
	manager.add(cknsIdtkCookie);

	      Cookie cknsAtknCookie = new
		Cookie(
			props.getProperty(&quot;cookie_name_ckns_atkn&quot;),
			props.getProperty(&quot;cookie_value_ckns_atkn&quot;), 
			props.getProperty(&quot;cookie_domain_ckns_atkn&quot;),
			props.getProperty(&quot;cookie_path_ckns_atkn&quot;), 
			Boolean.parseBoolean(props.getProperty(&quot;cookie_secure_ckns_atkn&quot;)), 
			Long.parseLong(props.getProperty(&quot;cookie_expires_ckns_atkn&quot;))
			);

	
	manager.add(cknsAtknCookie);
	
JMeterProperty cookieprop = 
ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;);
cookieprop.setObjectValue(manager);

//ctx.getCurrentSampler().setProperty(myprop);</stringProp>
            </JSR223PreProcessor>
            <hashTree/>
          </hashTree>
        </hashTree>
        <BackendListener guiclass="BackendListenerGui" testclass="BackendListener" testname="Backend Listener" enabled="true">
          <elementProp name="arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="testName" elementType="Argument">
                <stringProp name="Argument.name">testName</stringProp>
                <stringProp name="Argument.value">ugc-testname</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="nodeName" elementType="Argument">
                <stringProp name="Argument.name">nodeName</stringProp>
                <stringProp name="Argument.value">ugc-nodename</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBHost" elementType="Argument">
                <stringProp name="Argument.name">influxDBHost</stringProp>
                <stringProp name="Argument.value">127.0.0.1</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBPort" elementType="Argument">
                <stringProp name="Argument.name">influxDBPort</stringProp>
                <stringProp name="Argument.value">8086</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBUser" elementType="Argument">
                <stringProp name="Argument.name">influxDBUser</stringProp>
                <stringProp name="Argument.value">jmeter</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBPassword" elementType="Argument">
                <stringProp name="Argument.name">influxDBPassword</stringProp>
                <stringProp name="Argument.value"></stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBDatabase" elementType="Argument">
                <stringProp name="Argument.name">influxDBDatabase</stringProp>
                <stringProp name="Argument.value">ugcloadtest</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="retentionPolicy" elementType="Argument">
                <stringProp name="Argument.name">retentionPolicy</stringProp>
                <stringProp name="Argument.value">autogen</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="samplersList" elementType="Argument">
                <stringProp name="Argument.name">samplersList</stringProp>
                <stringProp name="Argument.value">.*</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="useRegexForSamplerList" elementType="Argument">
                <stringProp name="Argument.name">useRegexForSamplerList</stringProp>
                <stringProp name="Argument.value">true</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="classname">rocks.nt.apm.jmeter.JMeterInfluxDBBackendListenerClient</stringProp>
        </BackendListener>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Upload File - Login  Once Only" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <CookieManager guiclass="CookiePanel" testclass="CookieManager" testname="HTTP Cookie Manager" enabled="true">
          <collectionProp name="CookieManager.cookies"/>
          <boolProp name="CookieManager.clearEachIteration">true</boolProp>
        </CookieManager>
        <hashTree/>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">true</boolProp>
          <stringProp name="LoopController.loops">3</stringProp>
        </LoopController>
        <hashTree>
          <OnceOnlyController guiclass="OnceOnlyControllerGui" testclass="OnceOnlyController" testname="Login Only Once" enabled="true"/>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Session" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="Variables pr-dfinies" enabled="true">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
              <stringProp name="HTTPSampler.domain">session.test.bbc.co.uk</stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol">https</stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/session</stringProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.implementation">Java</stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="ExtractLoginLocation" enabled="true">
                <stringProp name="RegexExtractor.useHeaders">true</stringProp>
                <stringProp name="RegexExtractor.refname">LOCATION</stringProp>
                <stringProp name="RegexExtractor.regex">Location:\s+(.+)</stringProp>
                <stringProp name="RegexExtractor.template">$1$</stringProp>
                <stringProp name="RegexExtractor.default"></stringProp>
                <stringProp name="RegexExtractor.match_number">0</stringProp>
                <stringProp name="Sample.scope">all</stringProp>
              </RegexExtractor>
              <hashTree/>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="PostProcessor-SetLoginLocation" enabled="true">
                <stringProp name="scriptLanguage">groovy</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="script">import org.apache.jmeter.protocol.http.control.CookieManager
loc = vars.get(&quot;LOCATION&quot;)
log.info(&quot;LOCATION=&quot;+loc)
if (loc) {
	loc = new URL(loc)
	h = loc.getPath()+&quot;?&quot;+loc.query;
	props.put(&quot;LOGIN_PATH&quot;, h)
	props.put(&quot;LOGIN_HOST&quot;, loc.getHost())
	props.put(&quot;LOGIN_PROTOCOL&quot;, String.valueOf(loc.getProtocol()))

}

 
 

CookieManager manager = 
ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;).getObjectValue();
props.put(&quot;cookiecount&quot;,String.valueOf(manager.getCookieCount()));
for (int i=0;i&lt;manager.getCookieCount();i++){
                 // code to convert Cookie information to JMeter Properties
    props.put(&quot;cookie_name_&quot; + i, manager.get(i).getName());
    props.put(&quot;cookie_value_&quot;+i, manager.get(i).getValue());
    props.put(&quot;cookie_domain_&quot;+i, manager.get(i).getDomain());
    props.put(&quot;cookie_path_&quot;+i, manager.get(i).getPath());
    props.put(&quot;cookie_expires_&quot;+i, String.valueOf(manager.get(i).getExpires())); 
    props.put(&quot;cookie_secure_&quot;+i, String.valueOf(manager.get(i).getSecure()));

}
 </stringProp>
              </JSR223PostProcessor>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 PreProcessor" enabled="true">
                <stringProp name="scriptLanguage">groovy</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="script">sampler.getCookieManager().getCookies().clear();
</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 PreProcessor" enabled="true">
                <stringProp name="scriptLanguage">groovy</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="script">import org.apache.jmeter.protocol.http.sampler.HTTPSamplerProxy;
import org.apache.jmeter.protocol.http.control.CookieManager;

log.info(&quot;------------------- DING&quot;);
HTTPSamplerProxy hsp = ctx.getCurrentSampler();

hsp.setDomain(&quot;session.test.bbc.co.uk&quot;);
hsp.setPath(&quot;/session&quot;);
CookieManager manager = ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;).getObjectValue();
manager.recoverRunningVersion();
int cnt = manager.getCookieCount();
log.info(&quot;count = &quot;+cnt);
for(int i =0; i &lt; (cnt); i++){
	 log.info(&quot;---Hey:&quot;+manager.get(i).getName()+&quot;i=&quot;+i);
	 /*
	 try {
	 manager.remove(i);
	 } catch( javax.script.ScriptException e) {
	 	log.error(&quot;can not remove&quot;, e);
	 }
	 */
}


</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
            </hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Login" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="Variables pr-dfinies" enabled="true">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="username" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">ugc-under13-testuser1</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                    <stringProp name="Argument.name">username</stringProp>
                    <stringProp name="HTTPArgument.content_type">application/x-www-form-urlencoded</stringProp>
                  </elementProp>
                  <elementProp name="password" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">test4656</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                    <stringProp name="HTTPArgument.content_type">application/x-www-form-urlencoded</stringProp>
                    <stringProp name="Argument.name">password</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain">${__property(LOGIN_HOST)}</stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol">${__property(LOGIN_PROTOCOL)}</stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">${__property(LOGIN_PATH)}</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <boolProp name="HTTPSampler.BROWSER_COMPATIBLE_MULTIPART">true</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.implementation">Java</stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="Fetch CKNS_ATKN and CKNS_IDTKN cookies" enabled="true">
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="script">import org.apache.jmeter.protocol.http.control.*
//Get cookie manager
CookieManager cm = sampler.getCookieManager()


int cc = cm.getCookieCount()
log.info(&quot;************ NUMBER OF COOKIES&quot;+cc);
for(i =0; i &lt; cc; i++) {

	Cookie c = cm.get(i)
	log.info(&quot;POSTING:******************** Cookies #&quot;+i+&quot;: &quot; + c.getName() + &quot;   - cookie Value: &quot; + c.getValue())	

	if (c.getName().equalsIgnoreCase(&quot;ckns_atkn&quot;)) {
		props.put(&quot;UGC_CKNSATKN&quot;, c.getValue());
		props.put(&quot;cookie_name_ckns_atkn&quot;, c.getName());
          props.put(&quot;cookie_value_ckns_atkn&quot;, c.getValue());
          props.put(&quot;cookie_domain_ckns_atkn&quot;, c.getDomain());
          props.put(&quot;cookie_path_ckns_atkn&quot;, c.getPath());
          props.put(&quot;cookie_expires_ckns_atkn&quot;, String.valueOf(c.getExpires())); 
          props.put(&quot;cookie_secure_ckns_atkn&quot;, String.valueOf(c.getSecure()));
	}

	if (c.getName().equalsIgnoreCase(&quot;ckns_idtkn&quot;)) {
		props.put(&quot;UGC_CKNSIDTKN&quot;, c.getValue());
		props.put(&quot;cookie_name_ckns_idtkn&quot;, c.getName());
          props.put(&quot;cookie_value_ckns_idtkn&quot;, c.getValue());
          props.put(&quot;cookie_domain_ckns_idtkn&quot;, c.getDomain());
          props.put(&quot;cookie_path_ckns_idtkn&quot;, c.getPath());
          props.put(&quot;cookie_expires_ckns_idtkn&quot;, String.valueOf(c.getExpires())); 
          props.put(&quot;cookie_secure_ckns_idtkn&quot;, String.valueOf(c.getSecure()));

	}
	
	if (c.getName().equalsIgnoreCase(&quot;ckns_id-session-redirect&quot;)){

		props.put(&quot;UGC_ckns_id-session-redirect&quot;, c.getValue());
		props.put(&quot;UGC_ckns_id-session-redirect_DOMAIN&quot;, c.getDomain());
	}

}
</stringProp>
                <stringProp name="scriptLanguage">groovy</stringProp>
              </JSR223PostProcessor>
              <hashTree/>
              <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                <collectionProp name="Asserion.test_strings">
                  <stringProp name="-1648040284">500|302|200</stringProp>
                </collectionProp>
                <stringProp name="Assertion.custom_message"></stringProp>
                <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                <boolProp name="Assertion.assume_success">true</boolProp>
                <intProp name="Assertion.test_type">2</intProp>
              </ResponseAssertion>
              <hashTree/>
              <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="Preprocessor-AddSessionCookie" enabled="true">
                <stringProp name="scriptLanguage">groovy</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="cacheKey">true</stringProp>
                <stringProp name="script">//sampler.setProtocol(vars.get(&quot;LOGION_PROTOCOL&quot;))
//sampler.setDomain(vars.get(&quot;LOGIN_DOMAIN&quot;))
//sampler.setPath(vars.get(&quot;LOGIN_PATH&quot;))
//log.info(&quot;----- BEFORE LOGIN ${__property(UGC_CKNS_MVT)}&quot;)
import org.apache.jmeter.protocol.http.control.CookieManager;

import org.apache.jmeter.protocol.http.control.Cookie;
import org.apache.jmeter.testelement.property.JMeterProperty;
CookieManager manager = ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;).getObjectValue();
count = Integer.parseInt(props.getProperty(&quot;cookiecount&quot;));

for (int i=0; i&lt;count; i++) {
//	  log.info(&quot;----INSIDE &quot;+props.getProperty(&quot;cookie_name_&quot;+i);
 
       Cookie cookie = new
		Cookie(
			props.getProperty(&quot;cookie_name_&quot;+i),
			props.getProperty(&quot;cookie_value_&quot;+i), 
			props.getProperty(&quot;cookie_domain_&quot;+i),
			props.getProperty(&quot;cookie_path_&quot;+i), 
			Boolean.parseBoolean(props.getProperty(&quot;cookie_secure_&quot;+i)), 
			Long.parseLong(props.getProperty(&quot;cookie_expires_&quot;+i))
			);

	
	manager.add(cookie);
}
JMeterProperty cookieprop = 
ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;);
cookieprop.setObjectValue(manager);

//ctx.getCurrentSampler().setProperty(myprop);</stringProp>
              </JSR223PreProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Upload-Login" enabled="true">
            <elementProp name="HTTPsampler.Files" elementType="HTTPFileArgs">
              <collectionProp name="HTTPFileArgs.files">
                <elementProp name="${__P(test.data,&quot;hmm&quot;)}/1600px-Snake_River_5MB.jpg" elementType="HTTPFileArg">
                  <stringProp name="File.path">${__P(test.data,&quot;hmm&quot;)}/1600px-Snake_River_5MB.jpg</stringProp>
                  <stringProp name="File.paramname">data</stringProp>
                  <stringProp name="File.mimetype">image/jpeg</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="Variables pr-dfinies" enabled="true">
              <collectionProp name="Arguments.arguments">
                <elementProp name="txt10930738" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">email</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">txt10930738</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">www.int.bbc.co.uk</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">ugc/send/${campaignId}</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">true</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.implementation">Java</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="Extract SubmissionId" enabled="true">
              <stringProp name="JSONPostProcessor.referenceNames">subId</stringProp>
              <stringProp name="JSONPostProcessor.jsonPathExprs">$.submissionId</stringProp>
              <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
              <stringProp name="Sample.scope">variable</stringProp>
              <stringProp name="Scope.variable"></stringProp>
              <boolProp name="JSONPostProcessor.compute_concat">true</boolProp>
            </JSONPostProcessor>
            <hashTree/>
            <ResultSaver guiclass="ResultSaverGui" testclass="ResultSaver" testname="Save Responses to a file" enabled="true">
              <stringProp name="FileSaver.filename">${__P(test.results,&quot;hmm&quot;)}/upload.json</stringProp>
              <boolProp name="FileSaver.errorsonly">false</boolProp>
              <boolProp name="FileSaver.successonly">false</boolProp>
              <boolProp name="FileSaver.skipsuffix">false</boolProp>
              <boolProp name="FileSaver.skipautonumber">false</boolProp>
            </ResultSaver>
            <hashTree/>
            <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname=" PreProcessor-AddAuthenticationCookies" enabled="true">
              <stringProp name="scriptLanguage">groovy</stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="cacheKey">true</stringProp>
              <stringProp name="script">//sampler.setProtocol(vars.get(&quot;LOGION_PROTOCOL&quot;))
//sampler.setDomain(vars.get(&quot;LOGIN_DOMAIN&quot;))
//sampler.setPath(vars.get(&quot;LOGIN_PATH&quot;))
//log.info(&quot;----- BEFORE LOGIN ${__property(UGC_CKNS_MVT)}&quot;)
import org.apache.jmeter.protocol.http.control.CookieManager;

import org.apache.jmeter.protocol.http.control.Cookie;
import org.apache.jmeter.testelement.property.JMeterProperty;
CookieManager manager = ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;).getObjectValue();
count = Integer.parseInt(props.getProperty(&quot;cookiecount&quot;));

       Cookie cknsIdtkCookie = new
		Cookie(
			props.getProperty(&quot;cookie_name_ckns_idtkn&quot;),
			props.getProperty(&quot;cookie_value_ckns_idtkn&quot;), 
			props.getProperty(&quot;cookie_domain_ckns_idtkn&quot;),
			props.getProperty(&quot;cookie_path_ckns_idtkn&quot;), 
			Boolean.parseBoolean(props.getProperty(&quot;cookie_secure_ckns_idtkn&quot;)), 
			Long.parseLong(props.getProperty(&quot;cookie_expires_ckns_idtkn&quot;))
			);

	
	manager.add(cknsIdtkCookie);

	      Cookie cknsAtknCookie = new
		Cookie(
			props.getProperty(&quot;cookie_name_ckns_atkn&quot;),
			props.getProperty(&quot;cookie_value_ckns_atkn&quot;), 
			props.getProperty(&quot;cookie_domain_ckns_atkn&quot;),
			props.getProperty(&quot;cookie_path_ckns_atkn&quot;), 
			Boolean.parseBoolean(props.getProperty(&quot;cookie_secure_ckns_atkn&quot;)), 
			Long.parseLong(props.getProperty(&quot;cookie_expires_ckns_atkn&quot;))
			);

	
	manager.add(cknsAtknCookie);
	
JMeterProperty cookieprop = 
ctx.getCurrentSampler().getProperty(&quot;HTTPSampler.cookie_manager&quot;);
cookieprop.setObjectValue(manager);

//ctx.getCurrentSampler().setProperty(myprop);</stringProp>
            </JSR223PreProcessor>
            <hashTree/>
          </hashTree>
        </hashTree>
        <BackendListener guiclass="BackendListenerGui" testclass="BackendListener" testname="Backend Listener" enabled="true">
          <elementProp name="arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="testName" elementType="Argument">
                <stringProp name="Argument.name">testName</stringProp>
                <stringProp name="Argument.value">ugc-testname</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="nodeName" elementType="Argument">
                <stringProp name="Argument.name">nodeName</stringProp>
                <stringProp name="Argument.value">ugc-nodename</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBHost" elementType="Argument">
                <stringProp name="Argument.name">influxDBHost</stringProp>
                <stringProp name="Argument.value">127.0.0.1</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBPort" elementType="Argument">
                <stringProp name="Argument.name">influxDBPort</stringProp>
                <stringProp name="Argument.value">8086</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBUser" elementType="Argument">
                <stringProp name="Argument.name">influxDBUser</stringProp>
                <stringProp name="Argument.value">jmeter</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBPassword" elementType="Argument">
                <stringProp name="Argument.name">influxDBPassword</stringProp>
                <stringProp name="Argument.value"></stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="influxDBDatabase" elementType="Argument">
                <stringProp name="Argument.name">influxDBDatabase</stringProp>
                <stringProp name="Argument.value">ugcloadtest</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="retentionPolicy" elementType="Argument">
                <stringProp name="Argument.name">retentionPolicy</stringProp>
                <stringProp name="Argument.value">autogen</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="samplersList" elementType="Argument">
                <stringProp name="Argument.name">samplersList</stringProp>
                <stringProp name="Argument.value">.*</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
              <elementProp name="useRegexForSamplerList" elementType="Argument">
                <stringProp name="Argument.name">useRegexForSamplerList</stringProp>
                <stringProp name="Argument.value">true</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="classname">rocks.nt.apm.jmeter.JMeterInfluxDBBackendListenerClient</stringProp>
        </BackendListener>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
